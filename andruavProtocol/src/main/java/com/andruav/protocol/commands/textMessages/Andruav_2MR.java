package com.andruav.protocol.commands.textMessages;


import android.util.Base64;

import com.andruav.AndruavEngine;
import com.andruav.AndruavSettings;
import com.andruav.interfaces.INotification;
import com.andruav.protocol.commands.Andruav_Parser;
import com.andruav.protocol.commands.ProtocolHeaders;
import com.andruav.util.Ciphering;

import org.json.JSONException;
import org.json.JSONObject;

import java.text.ParseException;

import javax.crypto.BadPaddingException;

/**
 * This is the base class of all andruav text commands.
 * <br><br>Created by M.Hefny on 02-Oct-14.
 */
public class Andruav_2MR {


    /***
     * used internally by executor
     */
    public boolean processed = false;

    /**
     * if <b>true</b> then {@link #andruavMessageBase} text is encrypted.
     */
    public Boolean isEncrypted = false;
    /**
     * <b>true</b> means this instance received from another AndruavUnit not from Me.
     * <br><b>false</b> means this command is generated by Me and need to be sent to target or broadcasted.
     */
    public Boolean IsReceived = false;
    /**
     * if <b>true</b> then command contains error response.
     * <br>This does not means CRC error, but error response such as Login error due to bad login or accesscode.
     */
    public Boolean IsErr = false;
    public String MessageRouting;
    /**
     * if {@link #IsReceived} false then this is the UnitID name of the remote AndruavUnit.
     */
    public String partyID;

    public String groupName;
    /**
     * if {@link #IsReceived} true then this contains <b>myown UnitID</b>.
     * if {@link #IsReceived} false then this contains Unit--ID that I want to sendMessageToModule this command to.
     */
    public String targetName;
    /**
     * time set mainly before sending this command. used for commands such as <b>PING</b> system command.
     */
    public String timeStamp;
    // public long timeDiff;
    /**
     * Holds text commands.
     */
    public AndruavMessageBase andruavMessageBase;


    public Andruav_2MR() {

    }

    public Andruav_2MR(final boolean isReceived, final String messageCMDType, final String senderName) {
        super();
        IsReceived = isReceived;
        MessageRouting = messageCMDType;
        this.partyID = senderName;
        //this.groupName = groupName;
    }


    public void setMessageText (final String messageCMD) throws Exception
    {
        try
        {
            final JSONObject json_receive_data = new JSONObject(messageCMD);

            if (json_receive_data.has(ProtocolHeaders.MessageType)) { // message type

                int messageType = Integer.parseInt(json_receive_data.getString(ProtocolHeaders.MessageType));
                andruavMessageBase = Andruav_Parser.getAndruavMessage(messageType);
            } else {
                // no internal message exist.
                andruavMessageBase = new AndruavMessage_String();
            }


            if (json_receive_data.has(ProtocolHeaders.MSG_ROUTING)) { // command type
                MessageRouting = json_receive_data.getString(ProtocolHeaders.MSG_ROUTING);
            }
            else
            {
                MessageRouting = ProtocolHeaders.CMD_COMM_INDIVIDUAL;
            }
            if (json_receive_data.has(ProtocolHeaders.Sender)) { // sender
                partyID = json_receive_data.getString(ProtocolHeaders.Sender);
            }
            if (json_receive_data.has(ProtocolHeaders.Group)) { // group
                groupName = json_receive_data.getString(ProtocolHeaders.Group);
            }
            if (json_receive_data.has(ProtocolHeaders.TimeStamp)) { // time stamp
                timeStamp = json_receive_data.getString(ProtocolHeaders.TimeStamp);
                //andruav2MR.timeDiff = System.currentTimeMillis() - Long.parseLong(andruav2MR.timeStamp);
            }
            if (json_receive_data.has(ProtocolHeaders.Target)) { // target
                targetName = json_receive_data.getString(ProtocolHeaders.Target);
            }

            if (json_receive_data.has(ProtocolHeaders.Encryption)) {
                isEncrypted = json_receive_data.getBoolean(ProtocolHeaders.Encryption);
            } else {
                // enc non-existence means false not null
                isEncrypted = false;
            }

            if (json_receive_data.has(ProtocolHeaders.Message)) {
                setPayloadTextMessage(json_receive_data.getString(ProtocolHeaders.Message));
            }
        } catch (final BadPaddingException | JSONException e) {
            AndruavEngine.notification().displayNotification(INotification.NOTIFICATION_TYPE_ERROR, "Error", "Bad encryption key", true, INotification.INFO_TYPE_PROTOCOL, false);
            return ;
        }
    }

    /***
     * takes the internal message "payload" and interpret it using {@link AndruavMessageBase} or on of its children
     *
     * @param messageText
     * @throws JSONException
     * @throws ParseException
     */
    public void setPayloadTextMessage(final String messageText) throws Exception {

        if (andruavMessageBase == null) {
            andruavMessageBase = new AndruavMessage_String(messageText);
        }

        if (isEncrypted) {
            andruavMessageBase.setMessageText(new String(Ciphering.decrypt(AndruavSettings.encryptionkey, Base64.decode(messageText, Base64.DEFAULT))));

        } else {
            andruavMessageBase.setMessageText(messageText);
        }
    }

    /***
     * returns a complete Andruav_2MR external protocol "communication" as well as internal message command.
     *
     * @param addTime if <b>tyue</b> time field is initalized here
     * @return
     * @throws org.json.JSONException
     */
    public String getJscon(final Boolean addTime) throws Exception {
        JSONObject json_data = new JSONObject();
        if ((MessageRouting != null) && (!MessageRouting.isEmpty()))    json_data.put(ProtocolHeaders.MSG_ROUTING, MessageRouting);
        if ((partyID != null) && (!partyID.isEmpty()))                  json_data.put(ProtocolHeaders.Sender, partyID);
        if ((groupName != null) && (!groupName.isEmpty()))              json_data.put(ProtocolHeaders.Group, groupName);

        json_data.put(ProtocolHeaders.MessageType, andruavMessageBase.messageTypeID);
        if (targetName != null) {
            json_data.put(ProtocolHeaders.Target, targetName);
        }
        if (isEncrypted) {
            json_data.put(ProtocolHeaders.Encryption, true);
        }
        if (addTime) {
            json_data.put(ProtocolHeaders.TimeStamp, System.currentTimeMillis());
        }


        // concatenate HeaderCommMessage + InternalMessage
        if (isEncrypted) {
            String encmsg = Base64.encodeToString(Ciphering.encrypt(AndruavSettings.encryptionkey, getJsonMessage().getBytes()), Base64.DEFAULT);
            json_data.put(ProtocolHeaders.Message, encmsg);
        } else {
            json_data.accumulate(ProtocolHeaders.Message, new JSONObject(getJsonMessage()));
        }

        return json_data.toString();

    }

    /***
     * Gets internal command message json used to format the complete command string and filles {@link com.andruav.protocol.commands.ProtocolHeaders}Message attribute.
     *
     * @return string of {@link #andruavMessageBase#getJsonMessage()}
     * @throws org.json.JSONException
     */
    protected String getJsonMessage() throws Exception {
        return andruavMessageBase.getJsonMessage();
    }
}
